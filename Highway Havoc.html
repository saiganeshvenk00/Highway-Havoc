<!DOCTYPE html>
<html>
<head>
    <title>Highway Havoc</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.4.2/p5.min.js"></script>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background-color: #000;
            font-family: 'Arial', sans-serif;
        }
        canvas {
            display: block;
            margin: 0 auto;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
        }
        #mobileControls {
            position: fixed;
            bottom: 20px;
            width: 100%;
            display: flex;
            justify-content: space-around;
            z-index: 100;
        }
        .mobileBtn {
            background-color: rgba(0, 255, 255, 0.3);
            border: 2px solid rgba(0, 255, 255, 0.8);
            color: #fff;
            padding: 15px 30px;
            border-radius: 10px;
            font-size: 24px;
            touch-action: manipulation;
            cursor: pointer;
            transition: all 0.3s ease;
            z-index: 1000;
            position: relative;
        }
        .mobileBtn:active, .mobileBtn:hover {
            background-color: rgba(0, 255, 255, 0.6);
            transform: scale(1.1);
        }
        #gameButtons {
            position: fixed;
            top: 20px;
            right: 20px;
            display: flex;
            gap: 10px;
            z-index: 1000;
        }
        .achievement {
            position: fixed;
            right: -300px;
            background: rgba(0, 255, 255, 0.2);
            border: 2px solid rgba(0, 255, 255, 0.8);
            color: #fff;
            padding: 15px;
            border-radius: 10px;
            transition: right 0.5s ease;
            z-index: 1000;
        }
        .rulesPopup {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 20, 40, 0.95);
            border: 3px solid rgba(0, 255, 255, 0.8);
            border-radius: 15px;
            padding: 20px;
            width: 40%;
            max-width: 300px;
            height: 60vh;
            max-height: 450px;
            overflow-y: auto;
            z-index: 1000;
            box-shadow: 0 0 20px rgba(0, 255, 255, 0.3),
                        inset 0 0 50px rgba(0, 255, 255, 0.1);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: space-between;
        }
        .rulesTitle {
            color: #00ffff;
            text-align: center;
            font-size: 1.5em;
            margin-bottom: 20px;
            text-shadow: 0 0 10px rgba(0, 255, 255, 0.5);
            padding-bottom: 10px;
            border-bottom: 2px solid rgba(0, 255, 255, 0.3);
            width: 100%;
        }
        .rulesContent {
            color: #fff;
            font-size: 1em;
            line-height: 1.5;
            text-align: left;
            margin: 15px 0;
            padding: 0 15px;
            opacity: 0;
            transform: translateY(20px);
            animation: fadeInUp 0.5s forwards;
            flex-grow: 1;
            display: flex;
            flex-direction: column;
            justify-content: center;
        }
        .bullet-list {
            list-style: none;
            padding: 0;
            margin: 10px 0;
        }
        .bullet-point {
            position: relative;
            padding-left: 25px;
            margin: 8px 0;
            font-size: 0.95em;
            display: flex;
            align-items: center;
        }
        .bullet-point:before {
            content: '';
            position: absolute;
            left: 0;
            width: 8px;
            height: 8px;
            background: rgba(0, 255, 255, 0.8);
            border-radius: 50%;
            margin-top: 1px;
            box-shadow: 0 0 8px rgba(0, 255, 255, 0.5);
        }
        .bullet-point:after {
            content: '';
            position: absolute;
            left: 4px;
            top: 12px;
            width: 1px;
            height: calc(100% + 4px);
            background: rgba(0, 255, 255, 0.3);
            display: none;
        }
        .bullet-point:not(:last-child):after {
            display: block;
        }
        .bullet-icon {
            display: inline-block;
            margin-right: 8px;
            font-size: 1.1em;
            text-shadow: 0 0 10px rgba(0, 255, 255, 0.5);
        }
        @keyframes fadeInUp {
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }
        .rulesList {
            color: #fff;
            font-size: 1.2em;
            line-height: 1.6;
            width: 100%;
        }
        .ruleItem {
            margin: 15px 0;
            padding: 10px;
            border-left: 3px solid #00ffff;
            background: rgba(0, 255, 255, 0.1);
            border-radius: 5px;
            transition: all 0.3s ease;
        }
        .rulesButtons {
            display: flex;
            flex-direction: column;
            gap: 10px;
            margin-top: 15px;
            width: 100%;
        }
        .rulesButton {
            padding: 8px 20px;
            font-size: 1em;
            background: rgba(0, 255, 255, 0.2);
            border: 2px solid #00ffff;
            color: #00ffff;
            border-radius: 20px;
            cursor: pointer;
            transition: all 0.3s ease;
            width: 100%;
        }
        .rulesButton:hover {
            background: rgba(0, 255, 255, 0.4);
            transform: scale(1.02);
            box-shadow: 0 0 15px rgba(0, 255, 255, 0.3);
        }
        .phase-indicator {
            display: flex;
            flex-direction: column;
            gap: 8px;
            position: absolute;
            right: 15px;
            top: 50%;
            transform: translateY(-50%);
        }
        .phase-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: rgba(0, 255, 255, 0.3);
            border: 1px solid rgba(0, 255, 255, 0.8);
            transition: all 0.3s ease;
        }
        .phase-dot.active {
            background: rgba(0, 255, 255, 0.8);
            box-shadow: 0 0 10px rgba(0, 255, 255, 0.5);
            transform: scale(1.2);
        }
        .startButton {
            display: block;
            margin: 30px auto 0;
            padding: 15px 40px;
            font-size: 1.2em;
            background: rgba(0, 255, 255, 0.2);
            border: 2px solid #00ffff;
            color: #00ffff;
            border-radius: 25px;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        .startButton:hover {
            background: rgba(0, 255, 255, 0.4);
            transform: scale(1.05);
        }
        @media (max-height: 600px) {
            .rulesPopup {
                height: 70vh;
                padding: 15px;
                max-height: 400px;
            }
            .rulesTitle {
                font-size: 1.3em;
                margin-bottom: 10px;
            }
            .rulesContent {
                font-size: 0.9em;
                margin: 8px 0;
            }
            .rulesButton {
                padding: 6px 15px;
            }
        }
        @media (max-width: 480px) {
            .rulesPopup {
                width: 75%;
                padding: 15px;
            }
            .phase-indicator {
                right: 8px;
            }
            .phase-dot {
                width: 6px;
                height: 6px;
            }
        }
    </style>
</head>
<body>
    <div id="mobileControls">
        <button class="mobileBtn" id="leftBtn">‚Üê</button>
        <button class="mobileBtn" id="rightBtn">‚Üí</button>
    </div>
    <div id="gameButtons">
        <button class="mobileBtn" id="startBtn">Start</button>
        <button class="mobileBtn" id="restartBtn" style="display: none;">Restart</button>
    </div>
    <script>
        let player;
        let cars = [];
        let gameState = "rules";
        let score = 0;
        let lives = 3;
        let checkpoint = 0;
        let lastCheckpointTime = 0;
        let carSpeed = 3;
        let spawnRate = 0.02;
        let flashAlpha = 0;
        let canvasRatio = 2/3;
        let highScore = localStorage.getItem('highScore') || 0;
        let achievements = [];
        let combo = 0;
        let maxCombo = 0;
        let currentPhase = 1;
        
        // New variables for enhancements
        let isNightMode = false;
        let dayNightTransition = 0;
        let lastLevelChange = 0;
        let currentLevel = 1;
        let laneAnimOffset = 0;
        let bgColor = { r: 0, g: 20, b: 40 };
        let targetBgColor = { r: 0, g: 20, b: 40 };
        
        // Heart power-up variables
        let heartPowerUp = null;
        let heartSpawned = false;
        let heartCollected = false;
        let heartPulseSize = 0;
        let heartPulseDir = 1;
        
        // Achievement system
        const ACHIEVEMENTS = [
            { id: 'first_dodge', title: 'Quick Reflexes', desc: 'Dodge your first car', unlocked: false },
            { id: 'combo_5', title: 'Combo Master', desc: 'Get a 5x combo', unlocked: false },
            { id: 'score_100', title: 'Century', desc: 'Score 100 points', unlocked: false },
            { id: 'level_5', title: 'Survivor', desc: 'Reach Level 5', unlocked: false },
            { id: 'perfect_level', title: 'Perfect Run', desc: 'Complete a level without getting hit', unlocked: false }
        ];

        const INSTRUCTION_PHASES = [
            {
                title: "Welcome to Highway Havoc",
                content: `<div style="text-align: center; margin-bottom: 20px;">You're on the fastest highway, where survival is the only goal.</div>
                         <ul class="bullet-list">
                            <li class="bullet-point"><span class="bullet-icon">üéØ</span>Navigate through traffic</li>
                            <li class="bullet-point"><span class="bullet-icon">‚ö°</span>Test your reflexes</li>
                            <li class="bullet-point"><span class="bullet-icon">üèÜ</span>Build your high score</li>
                         </ul>`
            },
            {
                title: "Game Objective",
                content: `<ul class="bullet-list">
                            <li class="bullet-point"><span class="bullet-icon">üõ£Ô∏è</span>Master six lanes of intense traffic</li>
                            <li class="bullet-point"><span class="bullet-icon">üî¥</span>Red cars: Oncoming traffic in left lanes - High risk, high reward</li>
                            <li class="bullet-point"><span class="bullet-icon">üîµ</span>Blue cars: Same direction in right lanes - Safer but fewer points</li>
                            <li class="bullet-point"><span class="bullet-icon">üí°</span>Watch for headlight beams - they show direction of movement</li>
                            <li class="bullet-point"><span class="bullet-icon">üî•</span>Chain dodges to build combo multipliers</li>
                         </ul>`
            },
            {
                title: "How to Play",
                content: isMobile() ? 
                    `<ul class="bullet-list">
                        <li class="bullet-point"><span class="bullet-icon">üëÜ</span>Tap left side to move left</li>
                        <li class="bullet-point"><span class="bullet-icon">üëÜ</span>Tap right side to move right</li>
                        <li class="bullet-point"><span class="bullet-icon">‚ö°</span>Quick reactions are key</li>
                        <li class="bullet-point"><span class="bullet-icon">üéØ</span>Time your moves carefully</li>
                     </ul>` :
                    `<ul class="bullet-list">
                        <li class="bullet-point"><span class="bullet-icon">‚¨ÖÔ∏è</span>Left Arrow or 'A' to move left</li>
                        <li class="bullet-point"><span class="bullet-icon">‚û°Ô∏è</span>Right Arrow or 'D' to move right</li>
                        <li class="bullet-point"><span class="bullet-icon">‚ö°</span>React quickly to survive</li>
                        <li class="bullet-point"><span class="bullet-icon">üéØ</span>Plan your moves ahead</li>
                     </ul>`
            },
            {
                title: "Ready to Play?",
                content: `<div style="text-align: center;">
                            <div style="font-size: 1.2em; margin-bottom: 15px;">Time to hit the highway!</div>
                            <ul class="bullet-list">
                                <li class="bullet-point"><span class="bullet-icon">üí´</span>Prove your driving skills</li>
                                <li class="bullet-point"><span class="bullet-icon">üèÜ</span>Set new high scores</li>
                                <li class="bullet-point"><span class="bullet-icon">‚≠ê</span>Unlock achievements</li>
                            </ul>
                         </div>`
            }
        ];

        function isMobile() {
            return /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
        }

        function showInstructions() {
            const existingPopup = document.getElementById('rulesPopup');
            if (existingPopup) {
                existingPopup.remove();
            }

            const popup = document.createElement('div');
            popup.id = 'rulesPopup';
            popup.className = 'rulesPopup';

            const phase = INSTRUCTION_PHASES[currentPhase - 1];

            popup.innerHTML = `
                <h1 class="rulesTitle">${phase.title}</h1>
                <div class="rulesContent">${phase.content}</div>
                <div class="phase-indicator">
                    ${Array(4).fill(0).map((_, i) => 
                        `<div class="phase-dot${i + 1 === currentPhase ? ' active' : ''}"></div>`
                    ).join('')}
                </div>
                <div class="rulesButtons">
                    ${currentPhase === 4 ? `
                        <button class="rulesButton" onclick="startGame()">Start Game</button>
                        <button class="rulesButton" onclick="resetInstructions()">Replay Instructions</button>
                    ` : `
                        <button class="rulesButton" onclick="nextPhase()">Next</button>
                    `}
                </div>
            `;

            document.body.appendChild(popup);
        }

        function nextPhase() {
            if (currentPhase < 4) {
                currentPhase++;
                showInstructions();
            }
        }

        function resetInstructions() {
            currentPhase = 1;
            showInstructions();
        }

        function setup() {
            let canvasWidth, canvasHeight;
            if (windowWidth / windowHeight > canvasRatio) {
                canvasHeight = windowHeight * 0.9;
                canvasWidth = canvasHeight * canvasRatio;
            } else {
                canvasWidth = windowWidth * 0.9;
                canvasHeight = canvasWidth / canvasRatio;
            }
            let canvas = createCanvas(canvasWidth, canvasHeight);
            canvas.parent(document.body);
            
            player = new Player();
            
            // Setup controls
            const leftBtn = document.getElementById('leftBtn');
            const rightBtn = document.getElementById('rightBtn');
            const startBtn = document.getElementById('startBtn');
            const restartBtn = document.getElementById('restartBtn');
            
            leftBtn.addEventListener('touchstart', handleLeft);
            leftBtn.addEventListener('mousedown', handleLeft);
            rightBtn.addEventListener('touchstart', handleRight);
            rightBtn.addEventListener('mousedown', handleRight);
            startBtn.addEventListener('click', () => {
                if (gameState === "rules") {
                    showInstructions();
                }
            });
            restartBtn.addEventListener('click', resetGame);
            
            // Show initial instructions
            showInstructions();
            
            // Load achievements
            loadAchievements();
        }

        function windowResized() {
            let canvasWidth, canvasHeight;
            if (windowWidth / windowHeight > canvasRatio) {
                canvasHeight = windowHeight * 0.9;
                canvasWidth = canvasHeight * canvasRatio;
            } else {
                canvasWidth = windowWidth * 0.9;
                canvasHeight = canvasWidth / canvasRatio;
            }
            resizeCanvas(canvasWidth, canvasHeight);
        }

        function handleLeft(e) {
            e.preventDefault();
            if (gameState === "playing" && player.targetLane > 0) {
                player.targetLane--;
            }
        }

        function handleRight(e) {
            e.preventDefault();
            if (gameState === "playing" && player.targetLane < 5) {
                player.targetLane++;
            }
        }

        function startGame() {
            // Remove rules popup
            const popup = document.getElementById('rulesPopup');
            if (popup) {
                popup.remove();
            }
            
            gameState = "playing";
            const startBtn = document.getElementById('startBtn');
            const restartBtn = document.getElementById('restartBtn');
            startBtn.style.display = 'none';
            restartBtn.style.display = 'block';
            resetGame();
        }

        function showAchievement(achievement) {
            const elem = document.createElement('div');
            elem.className = 'achievement';
            elem.innerHTML = `üèÜ ${achievement.title}<br>${achievement.desc}`;
            elem.style.top = `${achievements.length * 100 + 20}px`;
            document.body.appendChild(elem);
            
            setTimeout(() => elem.style.right = '20px', 100);
            setTimeout(() => {
                elem.style.right = '-300px';
                setTimeout(() => elem.remove(), 500);
            }, 3000);
            
            achievements.push(achievement.id);
            localStorage.setItem('achievements', JSON.stringify(achievements));
        }

        function loadAchievements() {
            const saved = localStorage.getItem('achievements');
            if (saved) {
                achievements = JSON.parse(saved);
            }
        }

        function checkAchievements() {
            ACHIEVEMENTS.forEach(achievement => {
                if (!achievements.includes(achievement.id)) {
                    if (
                        (achievement.id === 'first_dodge' && score > 0) ||
                        (achievement.id === 'combo_5' && combo >= 5) ||
                        (achievement.id === 'score_100' && score >= 100) ||
                        (achievement.id === 'level_5' && checkpoint >= 4) ||
                        (achievement.id === 'perfect_level' && checkpoint > 0 && lives === 3)
                    ) {
                        showAchievement(achievement);
                    }
                }
            });
        }

        function draw() {
            background(0, 20, 40);
            
            if (gameState === "rules") {
                drawRules();
            } else if (gameState === "menu") {
                drawMenu();
            } else if (gameState === "playing") {
                playGame();
            } else if (gameState === "gameover") {
                drawGameOver();
            }
            
            if (flashAlpha > 0) {
                fill(255, 0, 0, flashAlpha);
                rect(0, 0, width, height);
                flashAlpha -= 5;
            }
        }

        function drawRules() {
            // Semi-transparent background
            fill(0, 0, 0, 200);
            rect(0, 0, width, height);
            
            // Rules title
            textSize(32);
            textAlign(CENTER, CENTER);
            
            // Use darker colors in night mode
            if (isNightMode) {
                fill(0, 128, 128, 200); // Darker cyan with transparency
            } else {
                fill(0, 255, 255); // Cyan color for TRON theme
            }
            
            text("HIGHWAY HAVOC - RULES", width/2, height/6);
            
            // Rules content
            textSize(18);
            textAlign(LEFT, TOP);
            let rulesText = [
                "‚Ä¢ Dodge traffic across 6 lanes of highway",
                "‚Ä¢ Change lanes with LEFT/RIGHT arrow keys",
                "‚Ä¢ Red cars (left lanes) are opposing traffic",
                "‚Ä¢ Blue cars (right lanes) are same-direction traffic",
                "‚Ä¢ Cars have headlights showing their direction of travel",
                "‚Ä¢ Stay in the same lane as a car to score points",
                "‚Ä¢ Chain multiple cars for combo multipliers",
                "‚Ä¢ Heart power-ups appear every 5 levels in the red lanes",
                "‚Ä¢ Collect hearts to gain an extra life",
                "‚Ä¢ Day/Night cycle alternates each level"
            ];
            
            let startY = height/4;
            let lineHeight = 30;
            
            for (let i = 0; i < rulesText.length; i++) {
                text(rulesText[i], width/4, startY + i * lineHeight);
            }
            
            // Back button
            textSize(24);
            textAlign(CENTER, CENTER);
            text("Click anywhere to return", width/2, height * 0.85);
        }

        function drawMenu() {
            fill(0, 255, 255); // Cyan color for TRON theme
            textSize(width * 0.08);
            textAlign(CENTER);
            text("Highway Havoc", width/2, height/3);
            textSize(width * 0.05);
            text("Press 'S' to Start", width/2, height/2);
            textSize(width * 0.03);
            text("Use ‚Üê ‚Üí arrows to change lanes", width/2, height/2 + height * 0.1);
            text("Headlights show the direction cars are moving", width/2, height/2 + height * 0.15);
            textAlign(LEFT);
        }

        function playGame() {
            // Update day/night cycle
            if (currentLevel > 0 && millis() - lastLevelChange > 1000) {
                // Check if we need to update the day/night mode based on level
                let shouldBeNightMode = currentLevel % 2 === 0;
                
                // Only trigger transition if the mode is changing
                if (shouldBeNightMode !== isNightMode) {
                    isNightMode = shouldBeNightMode;
                    dayNightTransition = 255;
                    lastLevelChange = millis();
                    
                    // Set target background colors
                    if (isNightMode) {
                        targetBgColor = { r: 0, g: 10, b: 20 }; // Darker version of day mode
                    } else {
                        targetBgColor = { r: 0, g: 20, b: 40 }; // Normal colors for day mode
                    }
                }
            }
            
            // Smooth background color transition
            bgColor.r = lerp(bgColor.r, targetBgColor.r, 0.05);
            bgColor.g = lerp(bgColor.g, targetBgColor.g, 0.05);
            bgColor.b = lerp(bgColor.b, targetBgColor.b, 0.05);
            
            // Set background
            background(bgColor.r, bgColor.g, bgColor.b);
            
            // Draw lane indicators
            laneAnimOffset += 0.5;
            if (laneAnimOffset > height/20) laneAnimOffset = 0;
            
            for (let i = 0; i < 6; i++) {
                // UPDATED: Now lanes 0-2 are red (opposing) and lanes 3-5 are blue (same direction)
                if (i >= 3) {
                    // Blue lanes (same direction as player) - moving upward - RIGHT SIDE
                    // Use darker colors in night mode
                    if (isNightMode) {
                        fill(0, 75, 128, 20); // Darker blue with lower opacity
                    } else {
                        fill(0, 150, 255, 30); // Normal blue
                    }
                    // Draw upward arrows for same direction traffic
                    for (let y = -laneAnimOffset; y < height; y += height/20) {
                        drawArrow(i * width/6 + width/12, y, 1, isNightMode);
                    }
                } else {
                    // Red lanes (opposing traffic) - moving downward - LEFT SIDE
                    // Use darker colors in night mode
                    if (isNightMode) {
                        fill(128, 25, 50, 20); // Darker red with lower opacity
                    } else {
                        fill(255, 50, 100, 30); // Normal red
                    }
                    // Draw downward arrows for oncoming traffic
                    for (let y = -laneAnimOffset; y < height; y += height/20) {
                        drawArrow(i * width/6 + width/12, y, -1, isNightMode);
                    }
                }
                noStroke();
                rect(i * width/6, 0, width/6, height);
                
                // Lane dividers with glow effect
                let dividerColor = isNightMode ? color(0, 75, 128, 80) : color(0, 150, 255, 100);
                stroke(dividerColor);
                strokeWeight(2);
                line((i+1) * width/6, 0, (i+1) * width/6, height);
                
                if (isNightMode) {
                    // Add subtle glow to lane dividers
                    strokeWeight(4);
                    stroke(0, 75, 128, 15);
                    line((i+1) * width/6, 0, (i+1) * width/6, height);
                }
            }
            
            // Day/night transition overlay
            if (dayNightTransition > 0) {
                fill(0, 0, 0, dayNightTransition);
                rect(0, 0, width, height);
                dayNightTransition -= 5;
            }
            
            // Update and display player
            player.update();
            player.show();
            
            // Spawn and update cars
            if (random() < spawnRate) {
                cars.push(new Car(floor(random(6))));
            }
            
            // Handle heart power-up (every 5 levels)
            if (currentLevel % 5 === 0 && !heartSpawned && !heartCollected) {
                // Spawn heart on a red lane (0-2)
                let redLane = floor(random(3)); // 0, 1, or 2
                heartPowerUp = new Heart(redLane);
                heartSpawned = true;
                
                // Show heart notification
                const heartNotif = document.createElement('div');
                heartNotif.className = 'achievement';
                heartNotif.innerHTML = `‚ù§Ô∏è Extra Life Available!<br>Collect the heart in the left lanes!`;
                heartNotif.style.top = '30%';
                heartNotif.style.right = '50%';
                document.body.appendChild(heartNotif);
                setTimeout(() => heartNotif.remove(), 3000);
            }
            
            // Update and display heart power-up
            if (heartPowerUp) {
                heartPowerUp.update();
                heartPowerUp.show();
                
                // Check if player collected the heart
                if (heartPowerUp.hits(player)) {
                    lives++;
                    heartCollected = true;
                    heartPowerUp = null;
                    
                    // Show heart collected notification
                    const heartCollectedNotif = document.createElement('div');
                    heartCollectedNotif.className = 'achievement';
                    heartCollectedNotif.innerHTML = `‚ù§Ô∏è Extra Life Collected!<br>Lives: ${lives}`;
                    heartCollectedNotif.style.top = '30%';
                    heartCollectedNotif.style.right = '50%';
                    document.body.appendChild(heartCollectedNotif);
                    setTimeout(() => heartCollectedNotif.remove(), 2000);
                }
                
                // Remove heart if it goes offscreen
                if (heartPowerUp && heartPowerUp.offscreen()) {
                    heartPowerUp = null;
                }
            }
            
            // Update and display cars
            for (let i = cars.length - 1; i >= 0; i--) {
                cars[i].update();
                cars[i].show();
                
                if (cars[i].hits(player)) {
                    lives--;
                    combo = 0;
                    cars.splice(i, 1);
                    flashAlpha = 100;
                    if (lives <= 0) {
                        gameState = "gameover";
                    }
                    continue;
                }
                
                if (!cars[i].scored && cars[i].y > height/2 && cars[i].lane === player.lane) {
                    combo++;
                    maxCombo = Math.max(maxCombo, combo);
                    let comboPoints = (cars[i].direction === 1) ? 10 : 20;
                    comboPoints *= (1 + combo * 0.1);
                    score += Math.floor(comboPoints);
                    cars[i].scored = true;
                    
                    if (combo > 1) {
                        const elem = document.createElement('div');
                        elem.className = 'achievement';
                        elem.innerHTML = `${combo}x COMBO!`;
                        elem.style.top = '50%';
                        elem.style.right = '50%';
                        document.body.appendChild(elem);
                        setTimeout(() => elem.remove(), 1000);
                    }
                }
                
                if (cars[i].offscreen()) {
                    cars.splice(i, 1);
                }
            }
            
            // Progressive difficulty
            if (millis() - lastCheckpointTime > 10000) {
                // Level-based difficulty scaling with smoother transitions
                // Levels 1-5: Increase speed, keep spawn rate constant
                // Levels 6-10: Keep speed constant, increase spawn rate
                // Repeat pattern every 10 levels
                
                // Determine which phase we're in (speed increase or density increase)
                let levelGroup = Math.floor((currentLevel - 1) / 5);
                let isSpeedPhase = levelGroup % 2 === 0; // Even groups (0, 2, 4...) focus on speed
                let nextLevel = currentLevel + 1;
                let isTransitionLevel = nextLevel % 5 === 1; // Level before phase change
                
                // Calculate more balanced increases based on current level
                let speedIncrease, spawnRateIncrease;
                
                if (isSpeedPhase) {
                    // Speed increase phase (levels 1-5, 11-15, 21-25, etc.)
                    // More gradual speed increases that taper off
                    let levelInPhase = (currentLevel - 1) % 5 + 1;
                    speedIncrease = 0.25 - (levelInPhase * 0.01); // Slightly decreasing speed increases
                    spawnRateIncrease = 0.0005 + (levelInPhase * 0.0001); // Slightly increasing spawn rate
                } else {
                    // Density increase phase (levels 6-10, 16-20, 26-30, etc.)
                    // More gradual density increases that ramp up
                    let levelInPhase = (currentLevel - 1) % 5 + 1;
                    speedIncrease = 0.05 + (levelInPhase * 0.005); // Slightly increasing speed
                    spawnRateIncrease = 0.002 + (levelInPhase * 0.0005); // Ramping up spawn rate
                }
                
                // Apply increases
                carSpeed += speedIncrease;
                spawnRate += spawnRateIncrease;
                
                // Cap maximum values to prevent the game from becoming impossible
                carSpeed = Math.min(carSpeed, 12);
                spawnRate = Math.min(spawnRate, 0.15);
                
                lastCheckpointTime = millis();
                currentLevel++;
                
                // Reset heart power-up flags for the new level
                if (currentLevel % 5 !== 0) {
                    heartSpawned = false;
                    heartCollected = false;
                }
                
                // Show level up message with phase information
                const elem = document.createElement('div');
                elem.className = 'achievement';
                
                // Determine if this is the start of a new phase or a transition to a new phase
                let isNewPhase = currentLevel % 5 === 1;
                
                // Check if day/night mode should change
                let shouldBeNightMode = currentLevel % 2 === 0;
                let dayNightText = "";
                
                if (shouldBeNightMode !== isNightMode) {
                    dayNightText = shouldBeNightMode ? "<br>Night Mode Activated!" : "<br>Day Mode Activated!";
                }
                
                // Add heart notification for levels divisible by 5
                let heartText = "";
                if (currentLevel % 5 === 0) {
                    heartText = "<br>‚ù§Ô∏è Heart Power-up Available!";
                }
                
                if (isNewPhase) {
                    // New phase announcement
                    let phaseType = isSpeedPhase ? "Speed Phase" : "Density Phase";
                    elem.innerHTML = `Level ${currentLevel}!<br>${phaseType} Begins!${dayNightText}${heartText}`;
                    
                    // Play a more noticeable transition effect
                    dayNightTransition = 255; // Flash the screen
                    
                    // Show phase transition effect
                    const phaseTransition = document.createElement('div');
                    phaseTransition.className = 'achievement';
                    phaseTransition.style.background = 'rgba(0, 255, 255, 0.3)';
                    phaseTransition.style.border = '3px solid rgba(0, 255, 255, 0.9)';
                    phaseTransition.style.padding = '20px';
                    phaseTransition.style.fontSize = '1.2em';
                    phaseTransition.innerHTML = `<strong>${phaseType}</strong><br>Difficulty Shifting!`;
                    phaseTransition.style.top = '30%';
                    phaseTransition.style.right = '50%';
                    document.body.appendChild(phaseTransition);
                    setTimeout(() => phaseTransition.remove(), 3000);
                } else if (isTransitionLevel) {
                    // Warning about upcoming phase change
                    let nextPhaseType = isSpeedPhase ? "Density Phase" : "Speed Phase";
                    elem.innerHTML = `Level ${currentLevel}!<br>Warning: ${nextPhaseType} Coming Soon!${dayNightText}${heartText}`;
                } else {
                    // Regular level up
                    let phaseType = isSpeedPhase ? "Speed Increasing" : "Traffic Increasing";
                    elem.innerHTML = `Level ${currentLevel}!<br>${phaseType}${dayNightText}${heartText}`;
                }
                
                elem.style.top = '40%';
                elem.style.right = '50%';
                document.body.appendChild(elem);
                setTimeout(() => elem.remove(), 2500);
            }
            
            // UI elements
            drawUI();
        }

        function drawArrow(x, y, direction, isNight) {
            let arrowSize = width/30;
            let alpha = isNight ? 80 : 100;
            
            if (direction === 1) {
                if (isNight) {
                    fill(0, 75, 128, alpha); // Darker blue
                } else {
                    fill(0, 150, 255, alpha); // Normal blue
                }
            } else {
                if (isNight) {
                    fill(128, 25, 50, alpha); // Darker red
                } else {
                    fill(255, 50, 100, alpha); // Normal red
                }
            }
            
            beginShape();
            vertex(x, y + direction * arrowSize/2);
            vertex(x - arrowSize/4, y - direction * arrowSize/2);
            vertex(x + arrowSize/4, y - direction * arrowSize/2);
            endShape(CLOSE);
        }

        function drawUI() {
            // Score and lives
            if (isNightMode) {
                fill(0, 128, 128, 200); // Darker cyan with transparency
            } else {
                fill(0, 255, 255);
            }
            textSize(width * 0.04);
            text(`Score: ${score}`, width * 0.1, height * 0.05);
            
            // Heart symbols for lives
            textSize(width * 0.05);
            for (let i = 0; i < lives; i++) {
                text("‚ô•", width * 0.1 + i * width * 0.05, height * 0.1);
            }
            
            // High Score
            if (score > highScore) {
                highScore = score;
                localStorage.setItem('highScore', highScore);
            }
            textSize(width * 0.04);
            text(`High Score: ${highScore}`, width * 0.1, height * 0.15);
            
            // Level indicator
            text(`Level: ${currentLevel}`, width * 0.1, height * 0.2);
            
            // Progress bar
            if (isNightMode) {
                fill(0, 128, 128, 200); // Darker cyan with transparency
                noFill();
                stroke(0, 128, 128, 200);
            } else {
                fill(0, 255, 255);
                noFill();
                stroke(0, 255, 255);
            }
            rect(width * 0.3, height * 0.02, width * 0.4, height * 0.02);
            
            if (isNightMode) {
                fill(0, 128, 128, 80); // Darker cyan with more transparency
            } else {
                fill(0, 255, 255, 100);
            }
            rect(width * 0.3, height * 0.02, map(millis() - lastCheckpointTime, 0, 10000, 0, width * 0.4), height * 0.02);
        }

        function drawGameOver() {
            if (isNightMode) {
                fill(0, 128, 128, 200); // Darker cyan with transparency
            } else {
                fill(0, 255, 255); // Cyan color for TRON theme
            }
            textSize(width * 0.08);
            textAlign(CENTER);
            text("Game Over", width/2, height/3);
            textSize(width * 0.05);
            text(`Final Score: ${score}`, width/2, height/2);
            text(`Level Reached: ${currentLevel}`, width/2, height/2 + height * 0.1);
            text(`High Score: ${highScore}`, width/2, height/2 + height * 0.2);
            text("Press 'R' to Restart", width/2, height/2 + height * 0.3);
        }

        class Player {
            constructor() {
                this.lane = 4; // Start in a blue lane (right side)
                this.x = width/2;
                this.width = width * 0.07;
                this.height = height * 0.05;
                this.targetLane = 4; // Start in a blue lane (right side)
                this.glowSize = 0;
                this.glowDir = 1;
            }
            
            update() {
                // Smooth movement to target lane
                let targetX = this.targetLane * width/6 + width/12;
                this.x = lerp(this.x, targetX, 0.2);
                this.lane = this.targetLane;
                
                // Pulsating glow effect
                this.glowSize += 0.2 * this.glowDir;
                if (this.glowSize > 20) this.glowDir = -1;
                if (this.glowSize < 5) this.glowDir = 1;
            }
            
            show() {
                // Draw directional glow effect (extending upward)
                for (let i = 5; i > 0; i--) {
                    noStroke();
                    // Use darker colors in night mode
                    if (isNightMode) {
                        fill(128, 128, 0, 80 / i); // Darker yellow with lower opacity
                    } else {
                        fill(255, 255, 0, 150 / i); // Normal yellow
                    }
                    
                    // Oval glow that extends more upward than downward
                    ellipse(
                        this.x, 
                        height/2 + this.height * 0.3, // Shifted upward
                        this.width + this.glowSize * i, 
                        this.height * 1.5 + this.glowSize * i
                    );
                    
                    // Additional upward glow for motion effect
                    if (i < 3) {
                        beginShape();
                        vertex(this.x - this.width/3, height/2);
                        vertex(this.x + this.width/3, height/2);
                        vertex(this.x + this.width/4, height/2 - this.height * i * 0.5);
                        vertex(this.x - this.width/4, height/2 - this.height * i * 0.5);
                        endShape(CLOSE);
                    }
                }
                
                // Draw player car with headlights
                if (isNightMode) {
                    fill(128, 128, 0); // Darker yellow
                    stroke(0, 0, 0);
                } else {
                    fill(255, 255, 0);
                    stroke(255, 255, 255);
                }
                strokeWeight(2);
                rect(this.x - this.width/2, height/2, this.width, this.height, 5);
                
                // Car details (windshield and roof)
                if (isNightMode) {
                    fill(100, 100, 0); // Darker yellow detail
                } else {
                    fill(200, 200, 0);
                }
                rect(this.x - this.width/4, height/2, this.width/2, this.height/2, 2);
                
                // FLIPPED: Headlights at the BOTTOM of the car (front for upward movement)
                let headlightIntensity = 255; // Always full brightness
                fill(255, 255, headlightIntensity);
                
                // Make headlights larger in night mode
                let headlightSize = isNightMode ? this.height/2 : this.height/3;
                
                // Draw headlights at the bottom of the car
                ellipse(this.x - this.width/3, height/2 + this.height * 0.8, this.width/6, headlightSize);
                ellipse(this.x + this.width/3, height/2 + this.height * 0.8, this.width/6, headlightSize);
                
                // Headlight beams pointing upward from the bottom - always visible
                // Create gradient for headlight beams
                for (let i = 1; i <= 5; i++) {
                    noStroke();
                    // Brighter beams in night mode
                    let beamAlpha = isNightMode ? 40 / i : 40 / i;
                    fill(255, 255, 200, beamAlpha);
                    
                    // Left headlight beam - longer and more conical
                    let beamStartX = this.x - this.width/3;
                    let beamStartY = height/2 + this.height * 0.8;
                    // Longer beams in night mode
                    let beamLength = isNightMode ? this.height * 8 : this.height * 6;
                    let spreadFactor = 1.2; // How much the beam spreads
                    
                    // Left beam - now pointing upward from the bottom
                    beginShape();
                    vertex(beamStartX, beamStartY); // Beam start (at headlight)
                    // Left edge of beam
                    bezierVertex(
                        beamStartX - this.width * 0.3 * i * spreadFactor, beamStartY + beamLength * 0.3,
                        beamStartX - this.width * 0.4 * i * spreadFactor, beamStartY + beamLength * 0.6,
                        beamStartX - this.width * 0.5 * i * spreadFactor, beamStartY + beamLength
                    );
                    // Right edge of beam
                    bezierVertex(
                        beamStartX + this.width * 0.2 * i * spreadFactor, beamStartY + beamLength * 0.6,
                        beamStartX + this.width * 0.1 * i * spreadFactor, beamStartY + beamLength * 0.3,
                        beamStartX, beamStartY
                    );
                    endShape(CLOSE);
                    
                    // Right beam
                    beamStartX = this.x + this.width/3;
                    beginShape();
                    vertex(beamStartX, beamStartY);
                    // Left edge of beam
                    bezierVertex(
                        beamStartX - this.width * 0.1 * i * spreadFactor, beamStartY + beamLength * 0.3,
                        beamStartX - this.width * 0.2 * i * spreadFactor, beamStartY + beamLength * 0.6,
                        beamStartX - this.width * 0.3 * i * spreadFactor, beamStartY + beamLength
                    );
                    // Right edge of beam
                    bezierVertex(
                        beamStartX + this.width * 0.5 * i * spreadFactor, beamStartY + beamLength * 0.6,
                        beamStartX + this.width * 0.4 * i * spreadFactor, beamStartY + beamLength * 0.3,
                        beamStartX, beamStartY
                    );
                    endShape(CLOSE);
                }
                
                // Add extra glow effect at the beam source - brighter in night mode
                for (let i = 1; i <= 3; i++) {
                    let glowAlpha = isNightMode ? 30 / i : 30 / i;
                    fill(255, 255, 200, glowAlpha);
                    // Larger glow in night mode
                    let glowSize = isNightMode ? 1.5 : 1;
                    ellipse(this.x - this.width/3, height/2 + this.height * 0.8, 
                           this.width/3 * i * glowSize, this.height/2 * i * glowSize);
                    ellipse(this.x + this.width/3, height/2 + this.height * 0.8, 
                           this.width/3 * i * glowSize, this.height/2 * i * glowSize);
                }
                
                // Add taillights at the top
                fill(255, 50, 50, 255);
                ellipse(this.x - this.width/3, height/2 + this.height * 0.2, this.width/6, this.height/4);
                ellipse(this.x + this.width/3, height/2 + this.height * 0.2, this.width/6, this.height/4);
                
                strokeWeight(1);
            }
        }

        class Car {
            constructor(lane) {
                this.lane = lane;
                this.width = width * 0.07;
                this.height = height * 0.05;
                // UPDATED: Now lanes 0-2 are red (opposing) and lanes 3-5 are blue (same direction)
                this.direction = (lane < 3) ? -1 : 1;
                this.x = this.lane * width/6 + width/12;
                this.y = (this.direction === 1) ? -this.height : height;
                this.scored = false;
                
                // Adjust speed based on direction and current level
                // Calculate level group and phase for consistent difficulty scaling
                let levelGroup = Math.floor((currentLevel - 1) / 5);
                let isSpeedPhase = levelGroup % 2 === 0; // Even groups (0, 2, 4...) focus on speed
                let levelInPhase = (currentLevel - 1) % 5 + 1;
                let isTransitionLevel = levelInPhase === 5; // Last level in a phase
                
                // Base multiplier depends on direction
                let baseMultiplier = (this.direction === -1) ? 2.0 : 1.0;
                
                // Level-based scaling factor with smoother transitions
                let levelScaling;
                
                if (isSpeedPhase) {
                    // During speed phases, scale more with level but with diminishing returns
                    levelScaling = 0.05 + Math.min(0.35, levelInPhase * 0.07);
                } else {
                    // During density phases, scale minimally with level but still increase
                    levelScaling = 0.05 + Math.min(0.15, levelInPhase * 0.03);
                }
                
                // Apply transition smoothing - reduce speed jump between phases
                if (isTransitionLevel) {
                    // If we're at the last level of a phase, start transitioning to next phase
                    if (isSpeedPhase) {
                        // Transitioning from speed to density - reduce speed scaling slightly
                        levelScaling *= 0.9;
                    } else {
                        // Transitioning from density to speed - increase speed scaling slightly
                        levelScaling *= 1.1;
                    }
                }
                
                // Calculate final speed with more balanced scaling
                this.speed = carSpeed * baseMultiplier * (1 + levelScaling);
                
                // Apply direction-specific adjustments with better balance
                if (this.direction === -1) {
                    // Opposing traffic (red cars) - always faster but with balanced scaling
                    this.speed *= 1.1;
                    
                    // Add slight randomization to make gameplay less predictable but still fair
                    this.speed *= (0.95 + Math.random() * 0.1); // ¬±5% speed variation
                } else {
                    // Same-direction traffic (blue cars) - add slight randomization
                    this.speed *= (0.97 + Math.random() * 0.06); // ¬±3% speed variation
                }
                
                // UPDATED: Now lanes 0-2 are red and lanes 3-5 are blue
                if (this.direction === 1) {
                    this.color = color(0, 150, 255);
                    this.detailColor = color(100, 200, 255);
                } else {
                    this.color = color(255, 50, 100);
                    this.detailColor = color(255, 100, 150);
                }
            }
            
            update() {
                this.y += this.speed * this.direction;
            }
            
            show() {
                // Main car body
                if (isNightMode) {
                    // Use darker colors in night mode
                    if (this.direction === 1) {
                        fill(0, 75, 128); // Darker blue
                        stroke(0, 0, 0);
                    } else {
                        fill(128, 25, 50); // Darker red
                        stroke(0, 0, 0);
                    }
                } else {
                    fill(this.color);
                    stroke(255, 255, 255);
                }
                strokeWeight(2);
                rect(this.x - this.width/2, this.y, this.width, this.height, 5);
                
                // Car details - adjust position based on direction
                if (isNightMode) {
                    // Use darker colors in night mode
                    if (this.direction === 1) {
                        fill(0, 50, 100); // Darker blue detail
                    } else {
                        fill(100, 20, 40); // Darker red detail
                    }
                } else {
                    fill(this.detailColor);
                }
                rect(this.x - this.width/4, this.y + (this.direction === 1 ? 0 : this.height * 2/3), 
                     this.width/2, this.height/2, 2);
                
                // Lights with night mode enhancement
                if (this.direction === 1) {
                    // FLIPPED: For blue cars moving upward, headlights at the BOTTOM (front in direction of movement)
                    // Headlights at the bottom of the car - brighter in night mode
                    let headlightIntensity = isNightMode ? 255 : 255; // Always full brightness
                    fill(255, 255, headlightIntensity);
                    
                    // Make headlights larger in night mode
                    let headlightSize = isNightMode ? this.height/2 : this.height/3;
                    ellipse(this.x - this.width/3, this.y + this.height * 0.8, this.width/6, headlightSize);
                    ellipse(this.x + this.width/3, this.y + this.height * 0.8, this.width/6, headlightSize);
                    
                    // Taillights at the top
                    fill(255, 50, 50, 255); // Always full brightness
                    ellipse(this.x - this.width/3, this.y + this.height * 0.2, this.width/6, this.height/4);
                    ellipse(this.x + this.width/3, this.y + this.height * 0.2, this.width/6, this.height/4);
                    
                    // Headlight beams for blue cars - brighter and longer in night mode
                    for (let i = 1; i <= 3; i++) {
                        noStroke();
                        // Brighter beams in night mode
                        let beamAlpha = isNightMode ? 20 / i : 15 / i;
                        fill(255, 255, 200, beamAlpha);
                        
                        let beamWidth = this.width * (0.5 + i * 0.5);
                        // Longer beams in night mode
                        let beamHeight = isNightMode ? this.height * (1.5 + i) : this.height * (1 + i);
                        
                        // Upward-pointing headlight beams from the bottom of the car
                        triangle(
                            this.x, this.y + this.height * 0.9,
                            this.x - beamWidth/2, this.y + this.height + beamHeight,
                            this.x + beamWidth/2, this.y + this.height + beamHeight
                        );
                    }
                } else {
                    // FLIPPED: For red cars moving downward, headlights at the TOP (front in direction of movement)
                    // Headlights at the top of the car - brighter in night mode
                    let headlightIntensity = isNightMode ? 255 : 255; // Always full brightness
                    fill(255, 255, headlightIntensity);
                    
                    // Make headlights larger in night mode
                    let headlightSize = isNightMode ? this.height/2 : this.height/3;
                    ellipse(this.x - this.width/3, this.y + this.height * 0.2, this.width/6, headlightSize);
                    ellipse(this.x + this.width/3, this.y + this.height * 0.2, this.width/6, headlightSize);
                    
                    // Taillights at the bottom
                    fill(255, 50, 50, 255); // Always full brightness
                    ellipse(this.x - this.width/3, this.y + this.height * 0.8, this.width/6, this.height/4);
                    ellipse(this.x + this.width/3, this.y + this.height * 0.8, this.width/6, this.height/4);
                    
                    // Headlight beams for red cars - brighter and longer in night mode
                    for (let i = 1; i <= 3; i++) {
                        noStroke();
                        // Brighter beams in night mode
                        let beamAlpha = isNightMode ? 20 / i : 15 / i;
                        fill(255, 255, 200, beamAlpha);
                        
                        let beamWidth = this.width * (0.5 + i * 0.5);
                        // Longer beams in night mode
                        let beamHeight = isNightMode ? this.height * (1.5 + i) : this.height * (1 + i);
                        
                        // Downward-pointing headlight beams from the top of the car
                        triangle(
                            this.x, this.y + this.height * 0.1,
                            this.x - beamWidth/2, this.y - beamHeight,
                            this.x + beamWidth/2, this.y - beamHeight
                        );
                    }
                }
                
                strokeWeight(1);
            }
            
            hits(player) {
                return (this.lane === player.lane && 
                        this.y + this.height > height/2 && 
                        this.y < height/2 + player.height);
            }
            
            offscreen() {
                return (this.y > height || this.y + this.height < 0);
            }
        }

        class Heart {
            constructor(lane) {
                // Only spawn on red lanes (0-2)
                this.lane = lane;
                this.width = width * 0.05;
                this.height = width * 0.05;
                this.x = this.lane * width/6 + width/12;
                this.y = -this.height;
                this.speed = carSpeed * 0.7; // Move slower than cars
                this.collected = false;
                this.pulseAmount = 0;
                this.pulseDir = 1;
            }
            
            update() {
                // Move downward
                this.y += this.speed;
                
                // Pulsating effect
                this.pulseAmount += 0.05 * this.pulseDir;
                if (this.pulseAmount > 1.5) this.pulseDir = -1;
                if (this.pulseAmount < 0.5) this.pulseDir = 1;
            }
            
            show() {
                // Draw heart with pulsating effect
                noStroke();
                
                // Glowing effect
                for (let i = 3; i > 0; i--) {
                    if (isNightMode) {
                        fill(255, 50, 50, 100 / i); // Red in night mode too
                    } else {
                        fill(255, 50, 50, 100 / i); // Red heart
                    }
                    
                    // Heart shape with pulsating size
                    let size = this.width * (1 + this.pulseAmount * 0.2 * i);
                    heartShape(this.x, this.y, size);
                }
                
                // Main heart
                if (isNightMode) {
                    fill(255, 50, 50); // Keep heart red even in night mode
                } else {
                    fill(255, 50, 50);
                }
                heartShape(this.x, this.y, this.width);
            }
            
            hits(player) {
                return (this.lane === player.lane && 
                        this.y + this.height > height/2 && 
                        this.y < height/2 + player.height);
            }
            
            offscreen() {
                return (this.y > height);
            }
        }
        
        function heartShape(x, y, size) {
            beginShape();
            // Heart shape using bezier curves
            vertex(x, y + size * 0.3);
            bezierVertex(x, y, x - size/2, y - size/4, x - size/2, y - size/2);
            bezierVertex(x - size/2, y - size * 0.8, x, y - size * 0.7, x, y - size * 0.3);
            bezierVertex(x, y - size * 0.7, x + size/2, y - size * 0.8, x + size/2, y - size/2);
            bezierVertex(x + size/2, y - size/4, x, y, x, y + size * 0.3);
            endShape(CLOSE);
        }

        function keyPressed() {
            if (key === 's' && (gameState === "menu" || gameState === "rules")) {
                startGame();
            }
            if (key === 'r' && gameState === "gameover") {
                resetGame();
            }
            
            if (gameState === "playing") {
                if (keyCode === LEFT_ARROW && player.targetLane > 0) {
                    player.targetLane--;
                }
                if (keyCode === RIGHT_ARROW && player.targetLane < 5) {
                    player.targetLane++;
                }
            }
        }

        function resetGame() {
            // Reset game variables
            score = 0;
            lives = 3;
            combo = 0;
            maxCombo = 0;
            cars = [];
            currentLevel = 1;
            carSpeed = 3;
            spawnRate = 0.02;
            lastCheckpointTime = millis();
            gameState = "playing";
            player = new Player();
            
            // Reset day/night cycle
            isNightMode = currentLevel % 2 === 0; // Even levels are night mode
            dayNightTransition = 0;
            lastLevelChange = millis();
            laneAnimOffset = 0;
            
            // Set background colors based on day/night mode
            if (isNightMode) {
                bgColor = { r: 0, g: 10, b: 20 }; // Darker version of day mode
                targetBgColor = { r: 0, g: 10, b: 20 };
            } else {
                bgColor = { r: 0, g: 20, b: 40 }; // Normal colors for day mode
                targetBgColor = { r: 0, g: 20, b: 40 };
            }
            
            // Reset heart power-up variables
            heartPowerUp = null;
            heartSpawned = false;
            heartCollected = false;
            
            // Update button visibility
            const startBtn = document.getElementById('startBtn');
            const restartBtn = document.getElementById('restartBtn');
            startBtn.style.display = 'none';
            restartBtn.style.display = 'block';
            
            // Show starting message
            const elem = document.createElement('div');
            elem.className = 'achievement';
            elem.innerHTML = `Game Start!<br>Level ${currentLevel}`;
            elem.style.top = '40%';
            elem.style.right = '50%';
            document.body.appendChild(elem);
            setTimeout(() => elem.remove(), 2000);
        }
    </script>
</body>
</html>