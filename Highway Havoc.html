<!DOCTYPE html>
<html>
<head>
    <title>Highway Havoc</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.4.2/p5.min.js"></script>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background-color: #000;
            font-family: 'Arial', sans-serif;
        }
        canvas {
            display: block;
            margin: 0 auto;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
        }
        #mobileControls {
            position: fixed;
            bottom: 20px;
            width: 100%;
            display: flex;
            justify-content: space-around;
            z-index: 100;
        }
        .mobileBtn {
            background-color: rgba(0, 255, 255, 0.3);
            border: 2px solid rgba(0, 255, 255, 0.8);
            color: #fff;
            padding: 15px 30px;
            border-radius: 10px;
            font-size: 24px;
            touch-action: manipulation;
            cursor: pointer;
            transition: all 0.3s ease;
            z-index: 1000;
            position: relative;
        }
        .mobileBtn:active, .mobileBtn:hover {
            background-color: rgba(0, 255, 255, 0.6);
            transform: scale(1.1);
        }
        #gameButtons {
            position: fixed;
            top: 20px;
            right: 20px;
            display: flex;
            gap: 10px;
            z-index: 1000;
        }
        .achievement {
            position: fixed;
            right: -300px;
            background: rgba(0, 255, 255, 0.2);
            border: 2px solid rgba(0, 255, 255, 0.8);
            color: #fff;
            padding: 15px;
            border-radius: 10px;
            transition: right 0.5s ease;
            z-index: 1000;
        }
        .rulesPopup {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 20, 40, 0.95);
            border: 3px solid rgba(0, 255, 255, 0.8);
            border-radius: 15px;
            padding: 20px;
            width: 40%;
            max-width: 300px;
            height: 60vh;
            max-height: 450px;
            overflow-y: auto;
            z-index: 1000;
            box-shadow: 0 0 20px rgba(0, 255, 255, 0.3),
                        inset 0 0 50px rgba(0, 255, 255, 0.1);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: space-between;
        }
        .rulesTitle {
            color: #00ffff;
            text-align: center;
            font-size: 1.5em;
            margin-bottom: 20px;
            text-shadow: 0 0 10px rgba(0, 255, 255, 0.5);
            padding-bottom: 10px;
            border-bottom: 2px solid rgba(0, 255, 255, 0.3);
            width: 100%;
        }
        .rulesContent {
            color: #fff;
            font-size: 1em;
            line-height: 1.5;
            text-align: left;
            margin: 15px 0;
            padding: 0 15px;
            opacity: 0;
            transform: translateY(20px);
            animation: fadeInUp 0.5s forwards;
            flex-grow: 1;
            display: flex;
            flex-direction: column;
            justify-content: center;
        }
        .bullet-list {
            list-style: none;
            padding: 0;
            margin: 10px 0;
        }
        .bullet-point {
            position: relative;
            padding-left: 25px;
            margin: 8px 0;
            font-size: 0.95em;
            display: flex;
            align-items: center;
        }
        .bullet-point:before {
            content: '';
            position: absolute;
            left: 0;
            width: 8px;
            height: 8px;
            background: rgba(0, 255, 255, 0.8);
            border-radius: 50%;
            margin-top: 1px;
            box-shadow: 0 0 8px rgba(0, 255, 255, 0.5);
        }
        .bullet-point:after {
            content: '';
            position: absolute;
            left: 4px;
            top: 12px;
            width: 1px;
            height: calc(100% + 4px);
            background: rgba(0, 255, 255, 0.3);
            display: none;
        }
        .bullet-point:not(:last-child):after {
            display: block;
        }
        .bullet-icon {
            display: inline-block;
            margin-right: 8px;
            font-size: 1.1em;
            text-shadow: 0 0 10px rgba(0, 255, 255, 0.5);
        }
        @keyframes fadeInUp {
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }
        .rulesList {
            color: #fff;
            font-size: 1.2em;
            line-height: 1.6;
            width: 100%;
        }
        .ruleItem {
            margin: 15px 0;
            padding: 10px;
            border-left: 3px solid #00ffff;
            background: rgba(0, 255, 255, 0.1);
            border-radius: 5px;
            transition: all 0.3s ease;
        }
        .rulesButtons {
            display: flex;
            flex-direction: column;
            gap: 10px;
            margin-top: 15px;
            width: 100%;
        }
        .rulesButton {
            padding: 8px 20px;
            font-size: 1em;
            background: rgba(0, 255, 255, 0.2);
            border: 2px solid #00ffff;
            color: #00ffff;
            border-radius: 20px;
            cursor: pointer;
            transition: all 0.3s ease;
            width: 100%;
        }
        .rulesButton:hover {
            background: rgba(0, 255, 255, 0.4);
            transform: scale(1.02);
            box-shadow: 0 0 15px rgba(0, 255, 255, 0.3);
        }
        .phase-indicator {
            display: flex;
            flex-direction: column;
            gap: 8px;
            position: absolute;
            right: 15px;
            top: 50%;
            transform: translateY(-50%);
        }
        .phase-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: rgba(0, 255, 255, 0.3);
            border: 1px solid rgba(0, 255, 255, 0.8);
            transition: all 0.3s ease;
        }
        .phase-dot.active {
            background: rgba(0, 255, 255, 0.8);
            box-shadow: 0 0 10px rgba(0, 255, 255, 0.5);
            transform: scale(1.2);
        }
        .startButton {
            display: block;
            margin: 30px auto 0;
            padding: 15px 40px;
            font-size: 1.2em;
            background: rgba(0, 255, 255, 0.2);
            border: 2px solid #00ffff;
            color: #00ffff;
            border-radius: 25px;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        .startButton:hover {
            background: rgba(0, 255, 255, 0.4);
            transform: scale(1.05);
        }
        @media (max-height: 600px) {
            .rulesPopup {
                height: 70vh;
                padding: 15px;
                max-height: 400px;
            }
            .rulesTitle {
                font-size: 1.3em;
                margin-bottom: 10px;
            }
            .rulesContent {
                font-size: 0.9em;
                margin: 8px 0;
            }
            .rulesButton {
                padding: 6px 15px;
            }
        }
        @media (max-width: 480px) {
            .rulesPopup {
                width: 75%;
                padding: 15px;
            }
            .phase-indicator {
                right: 8px;
            }
            .phase-dot {
                width: 6px;
                height: 6px;
            }
        }
    </style>
</head>
<body>
    <div id="mobileControls">
        <button class="mobileBtn" id="leftBtn">‚Üê</button>
        <button class="mobileBtn" id="rightBtn">‚Üí</button>
    </div>
    <div id="gameButtons">
        <button class="mobileBtn" id="startBtn">Start</button>
        <button class="mobileBtn" id="restartBtn" style="display: none;">Restart</button>
    </div>
    <script>
        let player;
        let cars = [];
        let gameState = "rules";
        let score = 0;
        let lives = 3;
        let checkpoint = 0;
        let lastCheckpointTime = 0;
        let carSpeed = 3;
        let spawnRate = 0.02;
        let flashAlpha = 0;
        let canvasRatio = 2/3;
        let highScore = localStorage.getItem('highScore') || 0;
        let achievements = [];
        let combo = 0;
        let maxCombo = 0;
        let currentPhase = 1;
        
        // New variables for enhancements
        let isNightMode = false;
        let dayNightTransition = 0;
        let lastLevelChange = 0;
        let currentLevel = 1;
        let laneAnimOffset = 0;
        let bgColor = { r: 0, g: 20, b: 40 };
        let targetBgColor = { r: 0, g: 20, b: 40 };
        
        // Achievement system
        const ACHIEVEMENTS = [
            { id: 'first_dodge', title: 'Quick Reflexes', desc: 'Dodge your first car', unlocked: false },
            { id: 'combo_5', title: 'Combo Master', desc: 'Get a 5x combo', unlocked: false },
            { id: 'score_100', title: 'Century', desc: 'Score 100 points', unlocked: false },
            { id: 'level_5', title: 'Survivor', desc: 'Reach Level 5', unlocked: false },
            { id: 'perfect_level', title: 'Perfect Run', desc: 'Complete a level without getting hit', unlocked: false }
        ];

        const INSTRUCTION_PHASES = [
            {
                title: "Welcome to Highway Havoc",
                content: `<div style="text-align: center; margin-bottom: 20px;">You're on the fastest highway, where survival is the only goal.</div>
                         <ul class="bullet-list">
                            <li class="bullet-point"><span class="bullet-icon">üéØ</span>Navigate through traffic</li>
                            <li class="bullet-point"><span class="bullet-icon">‚ö°</span>Test your reflexes</li>
                            <li class="bullet-point"><span class="bullet-icon">üèÜ</span>Build your high score</li>
                         </ul>`
            },
            {
                title: "Game Objective",
                content: `<ul class="bullet-list">
                            <li class="bullet-point"><span class="bullet-icon">üõ£Ô∏è</span>Master six lanes of intense traffic</li>
                            <li class="bullet-point"><span class="bullet-icon">üî¥</span>Red cars: Oncoming traffic in right lanes - High risk, high reward</li>
                            <li class="bullet-point"><span class="bullet-icon">üîµ</span>Blue cars: Same direction in left lanes - Safer but fewer points</li>
                            <li class="bullet-point"><span class="bullet-icon">üí°</span>Watch for headlight beams showing car directions</li>
                            <li class="bullet-point"><span class="bullet-icon">üî•</span>Chain dodges to build combo multipliers</li>
                         </ul>`
            },
            {
                title: "How to Play",
                content: isMobile() ? 
                    `<ul class="bullet-list">
                        <li class="bullet-point"><span class="bullet-icon">üëÜ</span>Tap left side to move left</li>
                        <li class="bullet-point"><span class="bullet-icon">üëÜ</span>Tap right side to move right</li>
                        <li class="bullet-point"><span class="bullet-icon">‚ö°</span>Quick reactions are key</li>
                        <li class="bullet-point"><span class="bullet-icon">üéØ</span>Time your moves carefully</li>
                     </ul>` :
                    `<ul class="bullet-list">
                        <li class="bullet-point"><span class="bullet-icon">‚¨ÖÔ∏è</span>Left Arrow or 'A' to move left</li>
                        <li class="bullet-point"><span class="bullet-icon">‚û°Ô∏è</span>Right Arrow or 'D' to move right</li>
                        <li class="bullet-point"><span class="bullet-icon">‚ö°</span>React quickly to survive</li>
                        <li class="bullet-point"><span class="bullet-icon">üéØ</span>Plan your moves ahead</li>
                     </ul>`
            },
            {
                title: "Ready to Play?",
                content: `<div style="text-align: center;">
                            <div style="font-size: 1.2em; margin-bottom: 15px;">Time to hit the highway!</div>
                            <ul class="bullet-list">
                                <li class="bullet-point"><span class="bullet-icon">üí´</span>Prove your driving skills</li>
                                <li class="bullet-point"><span class="bullet-icon">üèÜ</span>Set new high scores</li>
                                <li class="bullet-point"><span class="bullet-icon">‚≠ê</span>Unlock achievements</li>
                            </ul>
                         </div>`
            }
        ];

        function isMobile() {
            return /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
        }

        function showInstructions() {
            const existingPopup = document.getElementById('rulesPopup');
            if (existingPopup) {
                existingPopup.remove();
            }

            const popup = document.createElement('div');
            popup.id = 'rulesPopup';
            popup.className = 'rulesPopup';

            const phase = INSTRUCTION_PHASES[currentPhase - 1];

            popup.innerHTML = `
                <h1 class="rulesTitle">${phase.title}</h1>
                <div class="rulesContent">${phase.content}</div>
                <div class="phase-indicator">
                    ${Array(4).fill(0).map((_, i) => 
                        `<div class="phase-dot${i + 1 === currentPhase ? ' active' : ''}"></div>`
                    ).join('')}
                </div>
                <div class="rulesButtons">
                    ${currentPhase === 4 ? `
                        <button class="rulesButton" onclick="startGame()">Start Game</button>
                        <button class="rulesButton" onclick="resetInstructions()">Replay Instructions</button>
                    ` : `
                        <button class="rulesButton" onclick="nextPhase()">Next</button>
                    `}
                </div>
            `;

            document.body.appendChild(popup);
        }

        function nextPhase() {
            if (currentPhase < 4) {
                currentPhase++;
                showInstructions();
            }
        }

        function resetInstructions() {
            currentPhase = 1;
            showInstructions();
        }

        function setup() {
            let canvasWidth, canvasHeight;
            if (windowWidth / windowHeight > canvasRatio) {
                canvasHeight = windowHeight * 0.9;
                canvasWidth = canvasHeight * canvasRatio;
            } else {
                canvasWidth = windowWidth * 0.9;
                canvasHeight = canvasWidth / canvasRatio;
            }
            let canvas = createCanvas(canvasWidth, canvasHeight);
            canvas.parent(document.body);
            
            player = new Player();
            
            // Setup controls
            const leftBtn = document.getElementById('leftBtn');
            const rightBtn = document.getElementById('rightBtn');
            const startBtn = document.getElementById('startBtn');
            const restartBtn = document.getElementById('restartBtn');
            
            leftBtn.addEventListener('touchstart', handleLeft);
            leftBtn.addEventListener('mousedown', handleLeft);
            rightBtn.addEventListener('touchstart', handleRight);
            rightBtn.addEventListener('mousedown', handleRight);
            startBtn.addEventListener('click', () => {
                if (gameState === "rules") {
                    showInstructions();
                }
            });
            restartBtn.addEventListener('click', resetGame);
            
            // Show initial instructions
            showInstructions();
            
            // Load achievements
            loadAchievements();
        }

        function windowResized() {
            let canvasWidth, canvasHeight;
            if (windowWidth / windowHeight > canvasRatio) {
                canvasHeight = windowHeight * 0.9;
                canvasWidth = canvasHeight * canvasRatio;
            } else {
                canvasWidth = windowWidth * 0.9;
                canvasHeight = canvasWidth / canvasRatio;
            }
            resizeCanvas(canvasWidth, canvasHeight);
        }

        function handleLeft(e) {
            e.preventDefault();
            if (gameState === "playing" && player.targetLane > 0) {
                player.targetLane--;
            }
        }

        function handleRight(e) {
            e.preventDefault();
            if (gameState === "playing" && player.targetLane < 5) {
                player.targetLane++;
            }
        }

        function startGame() {
            // Remove rules popup
            const popup = document.getElementById('rulesPopup');
            if (popup) {
                popup.remove();
            }
            
            gameState = "playing";
            const startBtn = document.getElementById('startBtn');
            const restartBtn = document.getElementById('restartBtn');
            startBtn.style.display = 'none';
            restartBtn.style.display = 'block';
            resetGame();
        }

        function showAchievement(achievement) {
            const elem = document.createElement('div');
            elem.className = 'achievement';
            elem.innerHTML = `üèÜ ${achievement.title}<br>${achievement.desc}`;
            elem.style.top = `${achievements.length * 100 + 20}px`;
            document.body.appendChild(elem);
            
            setTimeout(() => elem.style.right = '20px', 100);
            setTimeout(() => {
                elem.style.right = '-300px';
                setTimeout(() => elem.remove(), 500);
            }, 3000);
            
            achievements.push(achievement.id);
            localStorage.setItem('achievements', JSON.stringify(achievements));
        }

        function loadAchievements() {
            const saved = localStorage.getItem('achievements');
            if (saved) {
                achievements = JSON.parse(saved);
            }
        }

        function checkAchievements() {
            ACHIEVEMENTS.forEach(achievement => {
                if (!achievements.includes(achievement.id)) {
                    if (
                        (achievement.id === 'first_dodge' && score > 0) ||
                        (achievement.id === 'combo_5' && combo >= 5) ||
                        (achievement.id === 'score_100' && score >= 100) ||
                        (achievement.id === 'level_5' && checkpoint >= 4) ||
                        (achievement.id === 'perfect_level' && checkpoint > 0 && lives === 3)
                    ) {
                        showAchievement(achievement);
                    }
                }
            });
        }

        function draw() {
            background(0, 20, 40);
            
            if (gameState === "rules") {
                drawRules();
            } else if (gameState === "menu") {
                drawMenu();
            } else if (gameState === "playing") {
                playGame();
            } else if (gameState === "gameover") {
                drawGameOver();
            }
            
            if (flashAlpha > 0) {
                fill(255, 0, 0, flashAlpha);
                rect(0, 0, width, height);
                flashAlpha -= 5;
            }
        }

        function drawRules() {
            // Create rules popup if it doesn't exist
            if (!document.getElementById('rulesPopup')) {
                const popup = document.createElement('div');
                popup.id = 'rulesPopup';
                popup.className = 'rulesPopup';
                popup.innerHTML = `
                    <div class="rulesTitle">Welcome to Highway Havoc!</div>
                    <div class="rulesList">
                        <div class="ruleItem">üöó Dodge oncoming traffic and survive!</div>
                        <div class="ruleItem">üéÆ Use ‚Üê ‚Üí arrows or buttons to change lanes</div>
                        <div class="ruleItem">‚ö†Ô∏è Red cars in right lanes are dangerous - they come towards you!</div>
                        <div class="ruleItem">üîµ Blue cars in left lanes go in your direction - less points but safer</div>
                        <div class="ruleItem">üí° All cars have bright headlights showing their direction</div>
                        <div class="ruleItem">üî• Build combos by dodging consecutive cars</div>
                        <div class="ruleItem">üìà Reach higher levels for greater challenges</div>
                        <div class="ruleItem">üèÜ Unlock achievements to prove your skill!</div>
                        <div class="ruleItem">üí´ Ready to become a Highway Legend?</div>
                    </div>
                    <button class="startButton" onclick="startGame()">START GAME</button>
                `;
                document.body.appendChild(popup);
            }
        }

        function drawMenu() {
            fill(0, 255, 255); // Cyan color for TRON theme
            textSize(width * 0.08);
            textAlign(CENTER);
            text("Highway Havoc", width/2, height/3);
            textSize(width * 0.05);
            text("Press 'S' to Start", width/2, height/2);
            textSize(width * 0.03);
            text("Use ‚Üê ‚Üí arrows or buttons to move", width/2, height/2 + height * 0.1);
            text("Watch for headlight beams to see car directions", width/2, height/2 + height * 0.15);
        }

        function playGame() {
            // Update day/night cycle
            if (currentLevel > 0 && currentLevel % 5 === 0 && millis() - lastLevelChange > 1000) {
                isNightMode = !isNightMode;
                dayNightTransition = 255;
                lastLevelChange = millis();
                
                // Set target background colors
                if (isNightMode) {
                    targetBgColor = { r: 0, g: 10, b: 30 };
                } else {
                    targetBgColor = { r: 0, g: 20, b: 40 };
                }
            }
            
            // Smooth background color transition
            bgColor.r = lerp(bgColor.r, targetBgColor.r, 0.05);
            bgColor.g = lerp(bgColor.g, targetBgColor.g, 0.05);
            bgColor.b = lerp(bgColor.b, targetBgColor.b, 0.05);
            
            // Set background
            background(bgColor.r, bgColor.g, bgColor.b);
            
            // Draw lane indicators
            laneAnimOffset += 0.5;
            if (laneAnimOffset > height/20) laneAnimOffset = 0;
            
            for (let i = 0; i < 6; i++) {
                // SWAPPED: Now lanes 0-2 are blue (same direction) and lanes 3-5 are red (opposing)
                if (i < 3) {
                    // Blue lanes (same direction as player) - moving upward
                    fill(0, 150, 255, 30);
                    // Draw upward arrows for same direction traffic
                    for (let y = -laneAnimOffset; y < height; y += height/20) {
                        drawArrow(i * width/6 + width/12, y, 1, isNightMode);
                    }
                } else {
                    // Red lanes (opposing traffic) - moving downward
                    fill(255, 50, 100, 30);
                    // Draw downward arrows for oncoming traffic
                    for (let y = -laneAnimOffset; y < height; y += height/20) {
                        drawArrow(i * width/6 + width/12, y, -1, isNightMode);
                    }
                }
                noStroke();
                rect(i * width/6, 0, width/6, height);
                
                // Lane dividers with glow effect
                let dividerColor = isNightMode ? color(0, 150, 255, 150) : color(0, 150, 255, 100);
                stroke(dividerColor);
                strokeWeight(2);
                line((i+1) * width/6, 0, (i+1) * width/6, height);
                
                if (isNightMode) {
                    // Add subtle glow to lane dividers
                    strokeWeight(4);
                    stroke(0, 150, 255, 30);
                    line((i+1) * width/6, 0, (i+1) * width/6, height);
                }
            }
            
            // Day/night transition overlay
            if (dayNightTransition > 0) {
                fill(0, 0, 0, dayNightTransition);
                rect(0, 0, width, height);
                dayNightTransition -= 5;
            }
            
            // Update and display player
            player.update();
            player.show();
            
            // Spawn and update cars
            if (random() < spawnRate) {
                cars.push(new Car(floor(random(6))));
            }
            
            // Update and display cars
            for (let i = cars.length - 1; i >= 0; i--) {
                cars[i].update();
                cars[i].show();
                
                if (cars[i].hits(player)) {
                    lives--;
                    combo = 0;
                    cars.splice(i, 1);
                    flashAlpha = 100;
                    if (lives <= 0) {
                        gameState = "gameover";
                    }
                    continue;
                }
                
                if (!cars[i].scored && cars[i].y > height/2 && cars[i].lane === player.lane) {
                    combo++;
                    maxCombo = Math.max(maxCombo, combo);
                    let comboPoints = (cars[i].direction === 1) ? 10 : 20;
                    comboPoints *= (1 + combo * 0.1);
                    score += Math.floor(comboPoints);
                    cars[i].scored = true;
                    
                    if (combo > 1) {
                        const elem = document.createElement('div');
                        elem.className = 'achievement';
                        elem.innerHTML = `${combo}x COMBO!`;
                        elem.style.top = '50%';
                        elem.style.right = '50%';
                        document.body.appendChild(elem);
                        setTimeout(() => elem.remove(), 1000);
                    }
                }
                
                if (cars[i].offscreen()) {
                    cars.splice(i, 1);
                }
            }
            
            // Progressive difficulty
            if (millis() - lastCheckpointTime > 10000) {
                carSpeed *= 1.1;
                spawnRate *= 1.1;
                lastCheckpointTime = millis();
                currentLevel++;
                
                // Show level up message
                const elem = document.createElement('div');
                elem.className = 'achievement';
                elem.innerHTML = `Level ${currentLevel}!`;
                elem.style.top = '40%';
                elem.style.right = '50%';
                document.body.appendChild(elem);
                setTimeout(() => elem.remove(), 2000);
            }
            
            // UI elements
            drawUI();
        }

        function drawArrow(x, y, direction, isNight) {
            let arrowSize = width/30;
            let alpha = isNight ? 150 : 100;
            
            noStroke();
            if (direction === 1) {
                fill(0, 150, 255, alpha);
            } else {
                fill(255, 50, 100, alpha);
            }
            
            beginShape();
            vertex(x, y + direction * arrowSize/2);
            vertex(x - arrowSize/4, y - direction * arrowSize/2);
            vertex(x + arrowSize/4, y - direction * arrowSize/2);
            endShape(CLOSE);
        }
        
        function drawUI() {
            // Score and lives
            fill(0, 255, 255);
            textSize(width * 0.04);
            text(`Score: ${score}`, width * 0.1, height * 0.05);
            
            // Heart symbols for lives
            textSize(width * 0.05);
            for (let i = 0; i < lives; i++) {
                text("‚ô•", width * 0.1 + i * width * 0.05, height * 0.1);
            }
            
            // High Score
            if (score > highScore) {
                highScore = score;
                localStorage.setItem('highScore', highScore);
            }
            textSize(width * 0.04);
            text(`High Score: ${highScore}`, width * 0.1, height * 0.15);
            
            // Level indicator
            text(`Level: ${currentLevel}`, width * 0.1, height * 0.2);
            
            // Progress bar
            noFill();
            stroke(0, 255, 255);
            rect(width * 0.3, height * 0.02, width * 0.4, height * 0.02);
            fill(0, 255, 255, 100);
            rect(width * 0.3, height * 0.02, map(millis() - lastCheckpointTime, 0, 10000, 0, width * 0.4), height * 0.02);
        }

        function drawGameOver() {
            fill(0, 255, 255); // Cyan color for TRON theme
            textSize(width * 0.08);
            textAlign(CENTER);
            text("Game Over", width/2, height/3);
            textSize(width * 0.05);
            text(`Final Score: ${score}`, width/2, height/2);
            text(`High Score: ${highScore}`, width/2, height/2 + height * 0.1);
            text("Press 'R' to Restart", width/2, height/2 + height * 0.2);
        }

        class Player {
            constructor() {
                this.lane = 2;
                this.x = width/2;
                this.width = width * 0.07;
                this.height = height * 0.05;
                this.targetLane = 2;
                this.glowSize = 0;
                this.glowDir = 1;
            }
            
            update() {
                // Smooth movement to target lane
                let targetX = this.targetLane * width/6 + width/12;
                this.x = lerp(this.x, targetX, 0.2);
                this.lane = this.targetLane;
                
                // Pulsating glow effect
                this.glowSize += 0.2 * this.glowDir;
                if (this.glowSize > 20) this.glowDir = -1;
                if (this.glowSize < 5) this.glowDir = 1;
            }
            
            show() {
                // Draw directional glow effect (extending upward)
                for (let i = 5; i > 0; i--) {
                    noStroke();
                    fill(255, 255, 0, 150 / i);
                    
                    // Oval glow that extends more upward than downward
                    ellipse(
                        this.x, 
                        height/2 + this.height * 0.3, // Shifted upward
                        this.width + this.glowSize * i, 
                        this.height * 1.5 + this.glowSize * i
                    );
                    
                    // Additional upward glow for motion effect
                    if (i < 3) {
                        beginShape();
                        vertex(this.x - this.width/3, height/2);
                        vertex(this.x + this.width/3, height/2);
                        vertex(this.x + this.width/4, height/2 - this.height * i * 0.5);
                        vertex(this.x - this.width/4, height/2 - this.height * i * 0.5);
                        endShape(CLOSE);
                    }
                }
                
                // Draw player car with headlights
                fill(255, 255, 0);
                stroke(255, 255, 255);
                strokeWeight(2);
                rect(this.x - this.width/2, height/2, this.width, this.height, 5);
                
                // Car details (windshield and roof)
                fill(200, 200, 0);
                rect(this.x - this.width/4, height/2, this.width/2, this.height/2, 2);
                
                // Headlights (brighter at night) - at the top of the car
                let headlightIntensity = 255; // Always full brightness
                fill(255, 255, headlightIntensity);
                let headlightSize = this.height/3; // Always use larger size
                
                // Draw headlights at the front (top) of the car
                ellipse(this.x - this.width/3, height/2 + this.height * 0.2, this.width/6, headlightSize);
                ellipse(this.x + this.width/3, height/2 + this.height * 0.2, this.width/6, headlightSize);
                
                // Headlight beams pointing upward - always visible
                // Create gradient for headlight beams
                for (let i = 1; i <= 5; i++) {
                    noStroke();
                    fill(255, 255, 200, 40 / i);
                    
                    // Left headlight beam - longer and more conical
                    let beamStartX = this.x - this.width/3;
                    let beamStartY = height/2 + this.height * 0.2;
                    let beamLength = this.height * 6; // Length of about 3 cars
                    let spreadFactor = 1.2; // How much the beam spreads
                    
                    // Left beam
                    beginShape();
                    vertex(beamStartX, beamStartY); // Beam start (at headlight)
                    // Left edge of beam
                    bezierVertex(
                        beamStartX - this.width * 0.3 * i * spreadFactor, beamStartY - beamLength * 0.3,
                        beamStartX - this.width * 0.4 * i * spreadFactor, beamStartY - beamLength * 0.6,
                        beamStartX - this.width * 0.5 * i * spreadFactor, beamStartY - beamLength
                    );
                    // Right edge of beam
                    bezierVertex(
                        beamStartX + this.width * 0.2 * i * spreadFactor, beamStartY - beamLength * 0.6,
                        beamStartX + this.width * 0.1 * i * spreadFactor, beamStartY - beamLength * 0.3,
                        beamStartX, beamStartY
                    );
                    endShape(CLOSE);
                    
                    // Right beam
                    beamStartX = this.x + this.width/3;
                    beginShape();
                    vertex(beamStartX, beamStartY);
                    // Left edge of beam
                    bezierVertex(
                        beamStartX - this.width * 0.1 * i * spreadFactor, beamStartY - beamLength * 0.3,
                        beamStartX - this.width * 0.2 * i * spreadFactor, beamStartY - beamLength * 0.6,
                        beamStartX - this.width * 0.3 * i * spreadFactor, beamStartY - beamLength
                    );
                    // Right edge of beam
                    bezierVertex(
                        beamStartX + this.width * 0.5 * i * spreadFactor, beamStartY - beamLength * 0.6,
                        beamStartX + this.width * 0.4 * i * spreadFactor, beamStartY - beamLength * 0.3,
                        beamStartX, beamStartY
                    );
                    endShape(CLOSE);
                }
                
                // Add extra glow effect at the beam source
                for (let i = 1; i <= 3; i++) {
                    let glowAlpha = 30 / i;
                    fill(255, 255, 200, glowAlpha);
                    ellipse(this.x - this.width/3, height/2 + this.height * 0.2, 
                           this.width/3 * i, this.height/2 * i);
                    ellipse(this.x + this.width/3, height/2 + this.height * 0.2, 
                           this.width/3 * i, this.height/2 * i);
                }
                
                // Add taillights at the bottom
                fill(255, 50, 50, 255);
                ellipse(this.x - this.width/3, height/2 + this.height * 0.8, this.width/6, this.height/4);
                ellipse(this.x + this.width/3, height/2 + this.height * 0.8, this.width/6, this.height/4);
                
                strokeWeight(1);
            }
        }

        class Car {
            constructor(lane) {
                this.lane = lane;
                this.width = width * 0.07;
                this.height = height * 0.05;
                // SWAPPED: Now lanes 0-2 are same direction (upward) and lanes 3-5 are opposing (downward)
                this.direction = (lane < 3) ? 1 : -1;
                this.x = this.lane * width/6 + width/12;
                this.y = (this.direction === 1) ? -this.height : height;
                this.scored = false;
                
                // Adjust speed based on direction and current level
                if (this.direction === -1) {
                    // Opposing traffic (red cars)
                    this.speed = carSpeed * 2.0 * (1 + currentLevel * 0.15);
                } else {
                    // Same direction traffic (blue cars)
                    this.speed = carSpeed * 1.0 * (1 + currentLevel * 0.1);
                }
                
                // SWAPPED: Now lanes 0-2 are blue and lanes 3-5 are red
                if (this.direction === 1) {
                    this.color = color(0, 150, 255);
                    this.detailColor = color(100, 200, 255);
                } else {
                    this.color = color(255, 50, 100);
                    this.detailColor = color(255, 100, 150);
                }
            }
            
            update() {
                this.y += this.speed * this.direction;
            }
            
            show() {
                // Main car body
                fill(this.color);
                stroke(255, 255, 255);
                strokeWeight(2);
                rect(this.x - this.width/2, this.y, this.width, this.height, 5);
                
                // Car details - adjust position based on direction
                fill(this.detailColor);
                rect(this.x - this.width/4, this.y + (this.direction === 1 ? 0 : this.height * 2/3), 
                     this.width/2, this.height/2, 2);
                
                // Lights with night mode enhancement
                if (this.direction === 1) {
                    // Headlights for blue cars (moving upward)
                    let headlightIntensity = 255; // Always full brightness
                    fill(255, 255, headlightIntensity);
                    ellipse(this.x - this.width/3, this.y + this.height * 0.2, this.width/6, this.height/3);
                    ellipse(this.x + this.width/3, this.y + this.height * 0.2, this.width/6, this.height/3);
                    
                    // Taillights at the bottom
                    fill(255, 50, 50, 255); // Always full brightness
                    ellipse(this.x - this.width/3, this.y + this.height * 0.8, this.width/6, this.height/4);
                    ellipse(this.x + this.width/3, this.y + this.height * 0.8, this.width/6, this.height/4);
                    
                    // Headlight beams for blue cars - always visible
                    for (let i = 1; i <= 3; i++) {
                        noStroke();
                        fill(255, 255, 200, 15 / i);
                        let beamWidth = this.width * (0.5 + i * 0.5);
                        let beamHeight = this.height * (1 + i);
                        
                        // Upward-pointing headlight beams
                        triangle(
                            this.x, this.y + this.height * 0.1,
                            this.x - beamWidth/2, this.y - beamHeight,
                            this.x + beamWidth/2, this.y - beamHeight
                        );
                    }
                } else {
                    // Headlights for red cars (moving downward)
                    let headlightIntensity = 255; // Always full brightness
                    fill(255, 255, headlightIntensity);
                    ellipse(this.x - this.width/3, this.y + this.height * 0.8, this.width/6, this.height/3);
                    ellipse(this.x + this.width/3, this.y + this.height * 0.8, this.width/6, this.height/3);
                    
                    // Taillights at the top
                    fill(255, 50, 50, 255); // Always full brightness
                    ellipse(this.x - this.width/3, this.y + this.height * 0.2, this.width/6, this.height/4);
                    ellipse(this.x + this.width/3, this.y + this.height * 0.2, this.width/6, this.height/4);
                    
                    // Headlight beams for red cars - always visible
                    for (let i = 1; i <= 3; i++) {
                        noStroke();
                        fill(255, 255, 200, 15 / i);
                        let beamWidth = this.width * (0.5 + i * 0.5);
                        let beamHeight = this.height * (1 + i);
                        
                        // Downward-pointing headlight beams
                        triangle(
                            this.x, this.y + this.height * 0.9,
                            this.x - beamWidth/2, this.y + this.height + beamHeight,
                            this.x + beamWidth/2, this.y + this.height + beamHeight
                        );
                    }
                }
                
                strokeWeight(1);
            }
            
            hits(player) {
                return (this.lane === player.lane && 
                        this.y + this.height > height/2 && 
                        this.y < height/2 + player.height);
            }
            
            offscreen() {
                return (this.y > height || this.y + this.height < 0);
            }
        }

        function keyPressed() {
            if (key === 's' && (gameState === "menu" || gameState === "rules")) {
                startGame();
            }
            if (key === 'r' && gameState === "gameover") {
                resetGame();
            }
            
            if (gameState === "playing") {
                if (keyCode === LEFT_ARROW && player.targetLane > 0) {
                    player.targetLane--;
                }
                if (keyCode === RIGHT_ARROW && player.targetLane < 5) {
                    player.targetLane++;
                }
            }
        }

        function resetGame() {
            score = 0;
            lives = 3;
            checkpoint = 0;
            lastCheckpointTime = millis();
            carSpeed = 3;
            spawnRate = 0.02;
            cars = [];
            player = new Player();
            gameState = "playing";
            combo = 0;
            maxCombo = 0;
            currentLevel = 1;
            isNightMode = false;
            dayNightTransition = 0;
            lastLevelChange = millis();
            bgColor = { r: 0, g: 20, b: 40 };
            targetBgColor = { r: 0, g: 20, b: 40 };
            laneAnimOffset = 0;
            
            // Update button visibility
            const startBtn = document.getElementById('startBtn');
            const restartBtn = document.getElementById('restartBtn');
            startBtn.style.display = 'none';
            restartBtn.style.display = 'block';
        }
    </script>
</body>
</html>